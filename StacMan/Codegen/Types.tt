<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="Manager.ttinclude" #>
<#@ assembly name="System.Web.Extensions" #>
<#@ output extension=".ignore" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Web.Script.Serialization" #>
<# // To debug, uncomment the next two lines
// System.Diagnostics.Debugger.Launch();
// System.Diagnostics.Debugger.Break();
#>
<#
var manager = Manager.Create(Host, GenerationEnvironment);
manager.StartHeader();
#>
// <auto-generated>
//     This file was generated by a T4 template.
//     Don't change it directly as your change would get overwritten. Instead, make changes
//     to the .tt file (i.e. the T4 template) and save it to regenerate this file.
// </auto-generated>

<#
manager.EndBlock();

var typesJson = File.ReadAllText(this.Host.ResolvePath("Types.json"));
var serializer = new JavaScriptSerializer();
var typesObj = serializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(typesJson);

foreach (var typeName in typesObj.Keys)
{
    var className = (typeName == "" ? "Wrapper<T>" : Prettify(typeName));
    manager.StartNewFile((typeName == "" ? "Wrapper" : Prettify(typeName)) + ".cs");
#>
// Make sure the compiler doesn't complain about missing Xml comments
#pragma warning disable 1591

using System;

namespace StackExchange.StacMan
{
    public partial class <#= className #> : StacManType
    {
        internal <#= className.Replace("<T>", "") #>(FilterBehavior filterBehavior, Filter filter) : base(filterBehavior, filter, "<#= typeName #>") { }
<# 
    var fieldsObj = typesObj[typeName];
        
    foreach (var field in fieldsObj)
    {
        var fieldName = field.Key;
        var propertyName = Prettify(fieldName);

        // member names cannot be the same as their enclosing type (this only affects "filter")
        if (propertyName == className)
            propertyName += "Name";

        var backingFieldName = "_" + propertyName;
        var propertyTypeName = field.Value;
#>

        private <#= propertyTypeName #> <#= backingFieldName #>;
        [Field("<#= fieldName #>")]
        public <#= propertyTypeName #> <#= propertyName #>
        {
            get { EnsureFilterContainsField("<#= fieldName #>"); return <#= backingFieldName #>; }
            internal set { <#= backingFieldName #> = value; }
        }
<#
    }
#>
    }
}

#pragma warning restore 1591
<#
    manager.EndBlock();
}
manager.Process(true);
#>

<#+
// convert "foo_bar" to "FooBar"
string Prettify(string name)
{
    var sb = new StringBuilder();
    bool capitalize = true;

    foreach (var c in name)
    {
        if (c == '_')
        {
            capitalize = true;
            continue;
        }

        if (capitalize)
        {
            sb.Append(char.ToUpper(c));
            capitalize = false;
        }
        else
        {
            sb.Append(c);
        }
    }

    return sb.ToString();
}
#>